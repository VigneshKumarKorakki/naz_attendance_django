<section class="block" data-stage="time">
  <p class="section-title muted" data-i18n="dash.system_time">
    System Date &amp; Time
  </p>
  <button class="cta" type="button" id="btn-start-work" data-i18n="dash.start_work" disabled>
    Start Work
    <span class="cta-subtext" id="start-time-text"></span>
  </button>
  <button class="cta secondary" type="button" id="btn-end-work" data-i18n="dash.end_work" disabled>
    End Work
    <span class="cta-subtext" id="end-time-text"></span>
  </button>
  <p class="section-title muted" data-i18n="dash.system_time">
    System Date &amp; Time
  </p>
  <div class="timer-display is-disabled" id="timer-display" data-i18n="dash.timer" aria-live="polite">
    Timer
  </div>
</section>

<button class="cta alt" type="button" id="btn-view-attendance" data-i18n="dash.view_attendance">
  View Attendance
</button>

<script>
// Encapsulate in DOMContentLoaded to ensure elements exist
document.addEventListener("DOMContentLoaded", () => {
  // Timer variables & elements
  let timerInterval;
  const timerDisplay = document.getElementById("timer-display");
  // If elements aren't found, we might be on a partial reload or they don't exist yet? 
  // But this is inside a partial that is included. 
  // Ideally, code inside partials is executed when included.
  // However, `const` at top level of a script in a partial might conflict if partial is loaded multiple times?
  // Let's use vars or strictly scoped.
  
  if (!timerDisplay) return; // Exit if elements missing (e.g. partial loaded but id changed)

  let timerStartTime = null;
  let lastStartIso = null;
  let lastEndIso = null;

  const getBundle = () => {
    const lang = localStorage.getItem("workerLang") || "en";
    return (window.I18N && (I18N[lang] || I18N.en)) || {};
  };
  const t = (key, fallback) => {
    const bundle = getBundle();
    if (bundle[key]) return bundle[key];
    const en = (window.I18N && I18N.en) || {};
    return en[key] || fallback || key;
  };
  
  const timeLabels = document.querySelectorAll(
    'p.section-title.muted[data-i18n="dash.system_time"]'
  );
  const startBtn = document.getElementById("btn-start-work");
  const endBtn = document.getElementById("btn-end-work");
  const startTimeText = document.getElementById("start-time-text");
  const endTimeText = document.getElementById("end-time-text");

  function isPastAttendanceDate() {
      const dateEl = document.querySelector(".date-info .date");
      const isoDate = dateEl?.dataset?.isoDate;
      if (!isoDate) return false;
      const selected = new Date(isoDate);
      if (Number.isNaN(selected.getTime())) return false;
      selected.setHours(0, 0, 0, 0);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return selected < today;
  }

  function applyDateGuard() {
      if (!startBtn) return;
      if (isPastAttendanceDate()) {
          startBtn.disabled = true;
          startBtn.dataset.dateLocked = "true";
          return;
      }
      if (startBtn.dataset.dateLocked === "true") {
          delete startBtn.dataset.dateLocked;
          startBtn.disabled = Boolean(startBtn.dataset.startTime);
      }
  }

  function getCurrentDateTime() {
    return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function formatTime(isoString) {
      const timeValue = new Date(isoString);
      if (Number.isNaN(timeValue.getTime())) {
          return "";
      }
      return timeValue
        .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        .toLowerCase();
  }

  function updateButtonState(startIso, endIso) {
      if (startBtn) {
          startBtn.disabled = Boolean(startIso);
          startBtn.dataset.startTime = startIso || "";
      }
      if (endBtn) {
          endBtn.disabled = !startIso || Boolean(endIso);
          endBtn.dataset.endTime = endIso || "";
      }
  }

  function updateTimeText(startIso, endIso) {
      if (startTimeText) {
          startTimeText.textContent = startIso ? `${t("time.start", "Start")}: ${formatTime(startIso)}` : "";
      }
      if (endTimeText) {
          endTimeText.textContent = endIso ? `${t("time.end", "End")}: ${formatTime(endIso)}` : "";
      }
  }

  function startTimerFrom(startIso) {
      if (!startIso) return;
      if (timerInterval) clearInterval(timerInterval);
      timerStartTime = new Date(startIso);
      if (Number.isNaN(timerStartTime.getTime())) {
          timerStartTime = null;
          return;
      }
      if (timerDisplay) {
          timerDisplay.classList.remove("is-disabled");
          timerInterval = setInterval(() => {
              const now = new Date();
              const diff = Math.max(0, now - timerStartTime);
              const totalSeconds = Math.floor(diff / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;

             const hStr = String(hours).padStart(2, '0');
              const mStr = String(minutes).padStart(2, '0');
              const sStr = String(seconds).padStart(2, '0');

              timerDisplay.textContent = `${hStr}:${mStr}:${sStr}`;
          }, 1000);
      }
  }

  function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      if (timerDisplay) {
          timerDisplay.classList.remove("is-disabled");
          timerStartTime = new Date();
          timerDisplay.textContent = "00:00:00";
          
          timerInterval = setInterval(() => {
              const now = new Date();
              const diff = Math.max(0, now - timerStartTime); // ms
              
              const totalSeconds = Math.floor(diff / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              
              const hStr = String(hours).padStart(2, '0');
              const mStr = String(minutes).padStart(2, '0');
              const sStr = String(seconds).padStart(2, '0');
              
              timerDisplay.textContent = `${hStr}:${mStr}:${sStr}`;
          }, 1000);
      }
  }
  
  function stopTimer() {
      if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
          
          if (timerStartTime && timerDisplay) {
             const now = new Date();
             const diffMs = now - timerStartTime;
             const hoursDecimal = (diffMs / (1000 * 60 * 60)).toFixed(2);
             timerDisplay.textContent = `${t("time.total", "Total")}: ${hoursDecimal} ${t("time.hours", "Hrs")}`;
          }
      }
  }

  function setTotalHours(startIso, endIso) {
      if (!timerDisplay) return;
      if (!startIso || !endIso) return;
      const startTime = new Date(startIso);
      const endTime = new Date(endIso);
      if (Number.isNaN(startTime.getTime()) || Number.isNaN(endTime.getTime())) {
          return;
      }
      const diffMs = Math.max(0, endTime - startTime);
      const hoursDecimal = (diffMs / (1000 * 60 * 60)).toFixed(2);
      timerDisplay.textContent = `${t("time.total", "Total")}: ${hoursDecimal} ${t("time.hours", "Hrs")}`;
      timerDisplay.classList.remove("is-disabled");
  }

  function applyShiftTimes(startIso, endIso) {
      lastStartIso = startIso || null;
      lastEndIso = endIso || null;
      updateTimeText(startIso, endIso);
      updateButtonState(startIso, endIso);
      const isPastDate = isPastAttendanceDate();
      
      if (timeLabels[0]) {
          if (startIso) {
              timeLabels[0].textContent = `${t("dash.start_time", "Start Time")}: ${formatTime(startIso)}`;
          } else if (isPastDate) {
              timeLabels[0].textContent = `${t("dash.start_time", "Start Time")}: --`;
          } else {
              timeLabels[0].textContent = t("dash.system_time", "System Date & Time");
          }
      }
      if (timeLabels[1]) {
          if (endIso) {
              timeLabels[1].textContent = `${t("dash.end_time", "End Time")}: ${formatTime(endIso)}`;
          } else if (isPastDate) {
              timeLabels[1].textContent = `${t("dash.end_time", "End Time")}: --`;
          } else {
              timeLabels[1].textContent = t("dash.system_time", "System Date & Time");
          }
      }
      if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
      }
      if (startIso && !endIso) {
          startTimerFrom(startIso);
          return;
      }
      if (startIso && endIso) {
          setTotalHours(startIso, endIso);
          return;
      }
      if (timerDisplay) {
          if (isPastDate) {
              timerDisplay.textContent = `${t("dash.timer", "Timer")}: --`;
          } else {
              timerDisplay.textContent = t("dash.timer", "Timer");
          }
          timerDisplay.classList.add("is-disabled");
      }
      applyDateGuard();
  }

  function ensureLocation() {
      if (window.workerLocation) {
          return true;
      }
      showToast("Please set your location before continuing.", "error");
      const locBtn = document.getElementById("get-location-btn");
      locBtn?.scrollIntoView({ behavior: "smooth", block: "center" });
      return false;
  }

  window.workerTimeUI = {
      applyShiftTimes,
  };

  applyShiftTimes(
      startBtn?.dataset.startTime || null,
      endBtn?.dataset.endTime || null
  );

  window.addEventListener("worker:language-changed", () => {
      applyShiftTimes(lastStartIso, lastEndIso);
  });
  window.addEventListener("attendance:date-changed", () => {
      applyDateGuard();
  });
  applyDateGuard();

  if (startBtn) {
      startBtn.addEventListener("click", async () => {
        // ... (existing start logic) ...
        if (!ensureLocation()) {
          return;
        }
        // 1. Gather all data
        const dateEl = document.querySelector('.date-info .date');
        const dateText = dateEl?.textContent.trim();
        const shiftBtn = document.querySelector('.option-btn[data-select-group="shift"].selected');
        const statusBtn = document.querySelector('.option-btn[data-select-group="attendance-primary"].selected');
        
        // 2. Validate
        if (!dateText) {
          showToast("Please select a date.", "error");
          return;
        }
        if (!shiftBtn) {
          showToast("Please select a valid shift (Day/Night).", "error");
          return;
        }
        const status = statusBtn?.dataset.attendancePrimary || "present";
        const shiftType = shiftBtn.dataset.shiftType;
        
        let absenceReason = null;
        if (status === "absent") {
           const reasonBtn = document.querySelector('.option-btn[data-select-group="attendance-secondary"].selected');
           if (reasonBtn) {
               const span = reasonBtn.querySelector("span");
               if (span) {
                   absenceReason = span.textContent.trim();
               } else {
                   absenceReason = reasonBtn.innerText.trim(); 
               }
           }
        }
        
        // 3. Format Date
        const monthMap = {
          "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04", "May": "05", "Jun": "06",
          "Jul": "07", "Aug": "08", "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
        };
        let formattedDate = dateEl?.dataset?.isoDate || "";
        if (!formattedDate) {
          const [day, monthStr, year] = dateText.split("-");
          const month = monthMap[monthStr];
          if (!month) {
            showToast("Invalid date format.", "error");
            return;
          }
          formattedDate = `${year}-${month}-${day}`;
        }

        if (timeLabels[0]) {
          timeLabels[0].textContent = `${t("dash.start_time", "Start Time")}: ${getCurrentDateTime()}`;
        }
        
        // 4. Construct Payload
        const actualNow = new Date();
        const combinedISO = actualNow.toISOString();

        startTimer();
        lastStartIso = combinedISO;

        const payload = {
           action: "start",
           attendance_date: formattedDate,
           shift_type: shiftType,
           status: status,
           absence_reason: absenceReason,
           worker_start_date_time: combinedISO,
           worker_start_location: window.workerLocation || null
        };
        
        console.log("Starting work with payload:", payload);

        const result = await saveShift(payload);
        if (result?.ok) {
            if (endBtn) endBtn.disabled = false;
            applyShiftTimes(combinedISO, null);
        }
      });
  }

  if (endBtn) {
      endBtn.addEventListener("click", async () => {
        if (!ensureLocation()) {
          return;
        }
        const dateEl = document.querySelector('.date-info .date');
        const dateText = dateEl?.textContent.trim();
        const shiftBtn = document.querySelector('.option-btn[data-select-group="shift"].selected');
        const statusBtn = document.querySelector('.option-btn[data-select-group="attendance-primary"].selected');
        const status = statusBtn?.dataset.attendancePrimary || "present";
        
        if (!dateText || !shiftBtn) {
           showToast("Missing Shift info.", "error");
           return;
        }

        const monthMap = {
          "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04", "May": "05", "Jun": "06",
          "Jul": "07", "Aug": "08", "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
        };
        let formattedDate = dateEl?.dataset?.isoDate || "";
        if (!formattedDate) {
          const [day, monthStr, year] = dateText.split("-");
          formattedDate = `${year}-${monthMap[monthStr]}-${day}`;
        }
        const shiftType = shiftBtn.dataset.shiftType;

        if (timeLabels[1]) {
          timeLabels[1].textContent = `${t("dash.end_time", "End Time")}: ${getCurrentDateTime()}`;
        }
        
        stopTimer();

        const actualNow = new Date();
        const combinedISO = actualNow.toISOString();

        const payload = {
            action: "end",
            attendance_date: formattedDate,
            shift_type: shiftType,
            status: status,
            worker_end_date_time: combinedISO,
            worker_end_location: window.workerLocation ? window.workerLocation : null
        };

        const result = await saveShift(payload);
        if (result?.ok) {
            endBtn.disabled = true;
            if (startBtn) startBtn.disabled = true;
            applyShiftTimes(lastStartIso, combinedISO);
        }
      });
  }

});
</script>
